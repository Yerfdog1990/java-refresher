1. Overview
   In this lesson, we’ll explore advanced strategies for generating and managing identifiers in Hibernate and JPA.

We’ll first examine the various ID generation options available and how they map to underlying database strategies. Then, we focus on composite primary keys, where an entity’s unique identifier spans multiple fields. Finally, we distinguish between natural and surrogate keys and assess the trade-offs of each in the context of domain-driven design.

The relevant module we need to import when starting with this lesson is: advanced-id-mapping-start.

For a fully implemented lesson as a reference, we can import: advanced-id-mapping-end.

2. ID Generation Strategies
   As we’ve seen, every JPA entity needs a unique identifier that we declare using the @Id annotation.

To avoid assigning IDs manually, we can use the @GeneratedValue annotation to delegate ID generation to the persistence provider.

JPA supports multiple strategies for ID generation. Each strategy maps to different database capabilities and behaviors, so it’s essential to understand when and why to use one over another.

Let’s walk through them, using examples and the resulting DDL from the H2 database, to see what’s happening behind the scenes.

2.1. AUTO Strategy
The simplest option is to let JPA choose a strategy automatically that it sees fit for the underlying database dialect.

With the AUTO strategy, JPA automatically selects the best ID generation strategy for the database (often sequences for PostgreSQL and identity columns for MySQL):

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
@Column(name = "id")
private Long id;

    // other fields, constructors, getters, and setters
}
Copy
Let’s run our application that uses an H2 database, and check the logs to see what strategy the provider has selected:

Hibernate:
create sequence Campaign_SEQ start with 1 increment by 50

    create table Campaign (
        id bigint not null,
        name varchar(50),
        code varchar(255) not null unique,
        description varchar(255),
        primary key (id)
    )
Copy
Here, Hibernate creates a sequence named Campaign_SEQ to generate values for the id column.

This strategy is portable, meaning, it allows our code to be reused across different database systems without requiring changes to the ID generation configuration. However, since this behavior can vary by database, it’s recommended to validate that the chosen strategy aligns well with our production environment.

2.2. IDENTITY Strategy
When working with databases like MySQL or H2 that support auto-increment columns, we can opt for the IDENTITY strategy:

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;

    // other fields, constructors, getters, and setters
}
Copy
Using this, Hibernate will instruct the H2 database to auto-increment the ID value on inserts using the identity column. This behavior ensures uniqueness and requires no additional configuration.

Let’s run the app and observe the DDL generated by Hibernate automatically:

Hibernate:
create table Campaign (
id bigint generated by default as identity,
name varchar(50),
code varchar(255) not null unique,
description varchar(255),
primary key (id)
)
Copy
The IDENTITY strategy will define an auto-increment id column that increments itself for each new row inserted into the table.

We should be cautious when using IDENTITY in high-throughput applications, as Hibernate cannot batch-insert entities with this strategy – it must execute each insert individually to retrieve the generated ID from the database.

2.3. UUID Strategy
When our application is distributed across multiple services or nodes, we may not want to rely on a centralized sequence or auto-increment column.

Then, UUIDs (Universally Unique Identifiers) are a good option because they can be generated independently without coordination.

To use this strategy, we can declare the id field as a UUID type and annotate it with @GeneratedValue following GenerationType.UUID as the generation strategy. 

Let’s make the changes to the Campaign class:

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id")
private UUID id;

    // other fields, constructors, getters, and setters
}
Copy
Once we run the application, we can see that the data type of the id column is UUID instead of bigint:

Hibernate:
create table Campaign (
id uuid not null,
name varchar(50),
code varchar(255) not null unique,
description varchar(255),
primary key (id)
)
Copy
Note that UUIDs consume relatively more space than numeric IDs (typically 128 bits vs. 64 bits for a long) and can impact database/query performance because of their randomness.

2.4. SEQUENCE Strategy
For databases like PostgreSQL and Oracle that support sequences, we can configure JPA to use them explicitly:

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "campaign_seq")
@Column(name = "id")
private Long id;

    // ...
}
Copy
Here, the campaign_seq sequence must be defined using the @SequenceGenerator annotation:

@Id
@SequenceGenerator(
name = "campaign_seq",
sequenceName = "campaign_sequence",
allocationSize = 1
)
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "campaign_seq")
@Column(name = "id")
private Long id;
Copy
When we run our application with H2 database, the SEQUENCE strategy creates the campaign_sequence, and the id column uses it for insertion:

Hibernate:
create sequence campaign_sequence start with 1 increment by 1

    create table Campaign (
        id bigint not null,
        name varchar(50),
        code varchar(255) not null unique,
        description varchar(255),
        primary key (id)
    )
Copy
This strategy separates ID generation from row insertion. Using sequences provides better support for batch inserts since Hibernate can pre-allocate IDs using the defined sequence.

Hence, the SEQUENCE strategy proves handy for high-throughput applications where sequences offer performance benefits.

2.5. TABLE Strategy
Finally, when we use an in-memory or embedded database that doesn’t support sequences or identity columns, we can use the TABLE strategy:

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "campaign_gen")
@Column(name = "id")
private Long id;

    // ...
}
Copy
Similar to the SEQUENCE strategy, we define a table-based ID generator using the @TableGenerator annotation:

@Id
@TableGenerator(
name = "campaign_gen",
table = "id_generator",
pkColumnName = "gen_name",
valueColumnName = "gen_value",
pkColumnValue = "campaign_id",
allocationSize = 1
)
@GeneratedValue(strategy = GenerationType.TABLE, generator = "campaign_gen")
@Column(name = "id")
private Long id;
Copy
This strategy uses a separate table to simulate sequence behavior – and it works well with H2, which fully supports table-based ID generation:

Hibernate:
create table Campaign (
id bigint not null,
name varchar(50),
code varchar(255) not null unique,
description varchar(255),
primary key (id)
)

    create table id_generator (
        gen_value bigint,
        gen_name varchar(255) not null,
        primary key (gen_name)
    )

    insert into id_generator(gen_name, gen_value) values ('campaign_id',0)
Copy
Here, Hibernate uses a separate table, id_generator, to track and increment ID values using the campaign_id value for the gen_name column.

Although this strategy seems flexible and portable, performance may degrade under high insert rates due to frequent reads and writes to the id_generator table.

So, we can conclude that it’s more portable across databases but comes with a performance cost due to the additional lookup.

3. Composite Primary Keys
   We should know that not all identifiers are single fields in business-related applications. Sometimes, an entity’s identity is a combination of values – for example, when representing a relationship between two entities.

A composite primary key uses multiple fields to identify an entity record uniquely.

Suppose we want to track permissions assigned to workers – we can model this using the PermissionWorker entity.

First, let’s create the PermissionWorkerPK class in the com.baeldung.lhj.persistence.model package and mark it with the @Embeddable annotation so it can be embedded as the primary key in the PermissionWorker entity:

@Embeddable
public class PermissionWorkerPK implements Serializable {
@Column(name = "worker_id")
private Long workerId;

    @Column(name = "permission_code")
    private String permissionCode;

    // ...
}
Copy
Here, the workerId and permissionCode combined act as the unique identifier for the PermissionWorker record.

Also, the class must implement Serializable and override equals() and hashCode() so that Hibernate can correctly track the entity in the persistence context.

Next, we’ll create the PermissionWorker entity in the com.baeldung.lhj.persistence.model package:

@Entity
public class PermissionWorker {
@EmbeddedId
private PermissionWorkerPK permissionWorkerPK;

    @Column(name = "enabled")
    private Boolean enabled;

    // constructors, getters, setters
}
Copy
Here, the primary key is defined by using the PermissionWorkerPk typed field, marked with the @EmbeddedId annotation.

Then, we’ll be required to register our PermissionWorker entity in the persistence.xml to make sure JPA recognizes the class:

<persistence-unit name="LHJ">
    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
    <!-- Define the classes -->
    <class>com.baeldung.lhj.persistence.model.PermissionWorker</class>

    <!-- properties -->
</persistence-unit>
Copy
Once the application runs, Hibernate generates the PermissionWorker table without the id column marked as the primary key:

Hibernate:
create table PermissionWorker (
enabled boolean,
worker_id bigint not null,
permission_code varchar(255) not null,
primary key (worker_id, permission_code)
)
Copy
Instead, the setup enforces a composite primary key combining worker_id and permission_code, ensuring that each permission can only be assigned once to a given worker.

Therefore, composite keys are beneficial when the identifier naturally spans multiple fields and when we want to avoid adding an artificial surrogate key.

Also, we can use the @IdClass annotation in place of the @EmbeddedId annotation to define the composite key.

4. Natural and Surrogate Keys
   When designing our entities, we often choose between a natural key or a surrogate key.

A surrogate key is a system-generated identifier with no business meaning and exists solely to identify rows uniquely.

For example, the id field in the Campaign entity is a surrogate key:

@Entity
public class Campaign {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;

    // other fields, constructors, getters, and setters
}
Copy
Surrogate keys are simple and efficient, especially for indexing and foreign key relationships.

In contrast, a natural key represents a meaningful, business-specific, unique identifier. For instance, the Campaign entity includes a unique code field:

@Entity
public class Campaign {
// ...

    @NaturalId 
    @Column(name = "code", unique = true, nullable = false, updatable = false)
    private String code;

    // other fields, constructors, getters, and setters
}
Copy
Since code naturally identifies each Campaign in the business domain, we can consider it a natural key.

Hibernate can use the @NaturalId annotation to optimize lookups, and we often use it in equals() and hashCode() implementations to check logical equality.

Similarly, Worker uses email as a natural identifier:

@Entity
public class Worker {
// ...

    @NaturalId 
    @Column(name = "email", unique = true, nullable = false)
    private String email;

    // other fields, constructors, getters, and setters
}
Copy
Using natural keys helps enforce business constraints and often improves equals() and hashCode() implementations. However, they should only be used when the attribute is guaranteed to remain stable and unique.

Surrogate keys are usually better suited for establishing relationships and improving performance, especially when the natural key might change over time.