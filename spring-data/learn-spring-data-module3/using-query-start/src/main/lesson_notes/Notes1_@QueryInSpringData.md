
---

# üìò **Lesson Notes: Using `@Query` in Spring Data JPA**

Spring Data JPA gives us two main ways of defining repository queries:

1. **Derived Query Methods** ‚Äì generated by parsing method names
2. **`@Query` Annotation** ‚Äì allows custom JPQL or SQL queries

Derived queries are great for small, simple operations, but when queries become complex‚Äîmultiple parameters, joins, grouping, projections, or advanced filtering‚Äîthe `@Query` annotation becomes essential.

This lesson covers **JPQL**, **native SQL**, **sorting**, **pagination**, **parameters**, **updates**, **modifying queries**, **collections**, **joins**, and **dynamic queries**.

---

# ----------------------------------------

# **1. What is `@Query`?**

`@Query` allows writing explicit **JPQL** or **native SQL** inside repository interfaces:

```java
@Query("select u from User u where u.status = 1")
List<User> findAllActiveUsers();
```

Why use it?

* More control than derived queries
* Supports complex filters
* Supports joins
* Can return DTOs or scalar values
* Works with native SQL
* Supports advanced LIKE patterns
* Works with pagination & sorting

---

# ----------------------------------------

# **2. Basic `@Query` Example**

Let‚Äôs begin with a query that finds a campaign with a specific name and description.

### **Repository**

```java
public interface CampaignRepository extends CrudRepository<Campaign, Long> {

    @Query("select c from Campaign c where c.name='Campaign 3' and c.description='About Campaign 3'")
    List<Campaign> findWithNameAndDescription();
}
```

### **Running the Query**

```java
public class UsingQueryApp implements ApplicationRunner {

    @Autowired
    CampaignRepository campaignRepository;

    @Override
    public void run(ApplicationArguments args) {
        List<Campaign> result = campaignRepository.findWithNameAndDescription();
        System.out.println(result);
    }
}
```

This query returns:

```
Campaign [id=3, code=C3, name=Campaign 3, description=About Campaign 3]
```

---

# ----------------------------------------

# **3. JPQL Queries**

JPQL = Java Persistence Query Language.
It is **object-based** (uses entity names and properties).
Spring uses JPQL by default in `@Query`.

Example:

```java
@Query("select c from Campaign c where c.code = 'C1'")
List<Campaign> findByCode();
```

Key advantages:

* Database-agnostic
* Uses entity names
* Safer than SQL

---

# ----------------------------------------

# **4. Returning Specific Columns (Projections)**

Derived queries **cannot return a single field**.

But `@Query` can:

```java
@Query("select c.name from Campaign c where c.code = 'C1'")
Optional<String> findNameByCode();
```

---

# ----------------------------------------

# **5. Aggregations and GROUP BY**

Example: Count tasks by due year.

```java
@Query("select count(*), year(t.dueDate) from Task t group by year(t.dueDate)")
List<List<Integer>> countByDueYear();
```

Usage:

```java
List<List<Integer>> stats = taskRepository.countByDueYear();

stats.forEach(row -> {
    Integer count = row.get(0);
    Integer year = row.get(1);
});
```

---

# ----------------------------------------

# **6. Native SQL Queries**

Use `nativeQuery = true`:

```java
@Query(value = "select * from campaign limit 1", nativeQuery = true)
Campaign findSingleCampaign();
```

Native queries:

* Use real table/column names
* No JPQL parsing
* Support database-specific features

---

# ----------------------------------------

# **7. Using Advanced LIKE Expressions**

Example: "ends with":

```java
@Query("select u from User u where u.firstname like %?1")
List<User> findByFirstnameEndsWith(String firstname);
```

---

# ----------------------------------------

# **8. Sorting With `@Query`**

### ‚úî Sorting with JPQL

```java
@Query("select u from User u")
List<User> findAllUsers(Sort sort);

userRepository.findAllUsers(Sort.by("lastname"));
```

### ‚úî Sorting with Functions (unsafe sort)

```java
userRepository.findAllUsers(JpaSort.unsafe("LENGTH(firstname)"));
```

---

# ----------------------------------------

# **9. Sorting Not Supported in Native Queries**

This is **invalid**:

```java
@Query(value = "select * from users", nativeQuery = true)
List<User> findUsers(Sort sort);   // ‚ùå will throw exception
```

---

# ----------------------------------------

# **10. Pagination**

### ‚úî JPQL Pagination

```java
@Query("select u from User u order by id")
Page<User> findAllUsers(Pageable pageable);
```

### ‚úî Native Pagination

Requires `countQuery`:

```java
@Query(
  value = "SELECT * FROM users ORDER BY id",
  countQuery = "SELECT count(*) FROM users",
  nativeQuery = true)
Page<User> findAllUsers(Pageable pageable);
```

---

# ----------------------------------------

# **11. Query Parameters**

## **Indexed Parameters**

```java
@Query("select u from User u where u.status = ?1")
User findByStatus(Integer status);
```

## **Named Parameters**

```java
@Query("select u from User u where u.email = :email")
User findByEmail(@Param("email") String email);
```

---

# ----------------------------------------

# **12. Collection Parameters (`IN`)**

```java
@Query("select u from User u where u.name in :names")
List<User> findByNames(@Param("names") Collection<String> names);
```

---

# ----------------------------------------

# **13. Modifying Queries (`UPDATE`, `DELETE`, `INSERT`)**

Must use `@Modifying`.

### ‚úî Update

```java
@Modifying
@Query("update User u set u.status = :status where u.name = :name")
int updateStatus(@Param("status") Integer status, @Param("name") String name);
```

### ‚úî Native Update

```java
@Modifying
@Query(value = "update users set status=? where name=?", nativeQuery = true)
int updateStatusNative(int status, String name);
```

### ‚úî Native Insert

```java
@Modifying
@Query(
  value = "insert into users (name, age, email, status) values (:name, :age, :email, :status)",
  nativeQuery = true)
void insertUser(...);
```

> ‚ùó `INSERT` is **not allowed** in JPQL; must be native.

---

# ----------------------------------------

# **14. Joining Tables With `@Query`**

## ‚úî JPQL with DTO Projection

```java
@Query("select new com.example.ResultDTO(c.id, o.id, p.id) " +
       "from Customer c join c.orders o join o.products p " +
       "where c.id = :id")
List<ResultDTO> findCustomerDetails(@Param("id") Long id);
```

## ‚úî Native with Maps

```java
@Query(value = "select c.*, o.*, p.* from customer c join customer_order o ...",
       nativeQuery = true)
List<Map<String, Object>> findDetails(Long id);
```

---

# ----------------------------------------

# **15. Raw Native Tuple Results**

```java
@NativeQuery("SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1")
Map<String, Object> findRawMapByEmail(String email);
```

---

# ----------------------------------------

# **16. Using SpEL Expressions (`#{...}`)**

Example: refer to the entity name dynamically:

```java
@Query("select u from #{#entityName} u where u.lastname = ?1")
List<User> findByLastname(String lastname);
```

Works with inheritance hierarchies.

---

# ----------------------------------------

# **17. Value Expressions for LIKE**

Appending wildcards:

```java
@Query("select u from User u where u.lastname like %:lastname%")
List<User> findByLastnameWithWildcard(String lastname);
```

---

# ----------------------------------------

# **18. Sanitizing LIKE Input**

```java
@Query("select u from User u where u.firstname like %?#{escape([0])}% escape ?#{escapeCharacter()}")
List<User> safeSearch(String namePart);
```

---

# ----------------------------------------

# **19. Query Rewriting (Advanced)**

Useful when modifying JPQL/SQL before execution.

```java
@Override
public String rewrite(String query, Sort sort) {
    return query.replace("original", "rewritten");
}
```

---

# ----------------------------------------

# **20. Dynamic Queries With Custom Repository**

When the `@Query` annotation isn‚Äôt enough (e.g., unknown number of parameters):

### Fragment Interface

```java
public interface UserRepositoryCustom {
    List<User> findUserByEmails(Set<String> emails);
}
```

### Implementation

```java
public class UserRepositoryCustomImpl implements UserRepositoryCustom {

    @PersistenceContext
    EntityManager em;

    @Override
    public List<User> findUserByEmails(Set<String> emails) {

        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<User> q = cb.createQuery(User.class);
        Root<User> root = q.from(User.class);

        List<Predicate> predicates = emails.stream()
             .map(e -> cb.like(root.get("email"), "%" + e + "%"))
             .toList();

        q.where(cb.or(predicates.toArray(Predicate[]::new)));

        return em.createQuery(q).getResultList();
    }
}
```

### Composite Repository

```java
public interface UserRepository extends JpaRepository<User,Integer>, UserRepositoryCustom {}
```

---

# ----------------------------------------

# **21. Conclusion**

`@Query` is one of the most powerful features of Spring Data JPA.

It enables:

* Full JPQL and SQL control
* Complex projections
* Joins
* Aggregations
* Sorting & pagination control
* Updates / deletes
* Native queries
* Dynamic queries via custom fragments

Use derived queries for simple cases.
Use `@Query` for **everything else**.

---
